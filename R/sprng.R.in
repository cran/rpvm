# Emacs: -*- r -*- vim: ft=r 
# $Id: sprng.R.in,v 1.5 2002/01/14 23:54:25 snake Exp $
#
# wrapper functions for SPRNG (Scalable Parallel Random Number Generator)
# library

.SPRNG.INIT.TAG <- 199

init.sprng.master <- function (children,                         
                               seed = .Random.seed[2],
                               prngkind = "default",
                               para = 0) {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    if (!is.character(prngkind) || length (prngkind) > 1) {
        stop ("'rngkind' must be a character string of length 1.")
    }
    if (!is.na (pmatch (prngkind, "default"))) {
        prngkind <- "LFG"
    }
    kind <- pmatch (prngkind, c ("LFG", "LCG", "LCG64",
                                 "CMRG", "MLFG", "PMLCG")) - 1
    if (is.na (kind)) {
        stop(paste("'", prngkind, "' is not a valid choice", sep = ""))
    }
    for (i in 1:length (children)) {
        .PVM.initsend ()
        .PVM.pkint (length (children) + 1)
        .PVM.pkint (i)
        .PVM.pkint (seed)
        .PVM.pkint (kind)
        .PVM.pkint (para)
        .PVM.send (children[i], .SPRNG.INIT.TAG)
    }
    .Call ("r_init_sprng", as.integer (kind),
           as.integer (0), as.integer (length (children) + 1),
           as.integer (seed), as.integer (para))
                                        # enable user-defined RNG
    RNGkind ("user")
}

init.sprng.slave <- function () {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    myparent <- .PVM.parent ()
    .PVM.recv (myparent, .SPRNG.INIT.TAG)
    nstream  <- .PVM.upkint (1)
    streamno <- .PVM.upkint (1)
    seed     <- .PVM.upkint (1)
    kind     <- .PVM.upkint (1)
    para     <- .PVM.upkint (1)
    .Call ("r_init_sprng", as.integer (kind),
           as.integer (streamno), as.integer (nstream),
           as.integer (seed), as.integer (para))
                                        # enable user-defined RNG
    RNGkind ("user")
}

init.sprng.group <- function (group,
                              rootinst = 0,
                              seed = .Random.seed[2],
                              prngkind = "default",
                              para = 0) {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    if (!is.character(prngkind) || length (prngkind) > 1) {
        stop ("'rngkind' must be a character string of length 1.")
    }
    if (!is.na (pmatch (prngkind, "default"))) {
        prngkind <- "LFG"
    } 
    kind <- pmatch (prngkind, c ("LFG", "LCG", "LCG64",
                                 "CMRG", "MLFG", "PMLCG")) - 1
    if (is.na (kind)) {
        stop(paste("'", prngkind, "' is not a valid choice", sep = ""))
    }
                                        # get my group instance number
    myinst <- .PVM.getinst ()
    if (myinst == rootinst) {
                                        # broadcast the init information if
                                        # I'm the root
        .PVM.initsend ()
        .PVM.pkint (seed)
        .PVM.pkint (kind)
        .PVM.pkint (para)
        .PVM.bcast (group, .SPRNG.INIT.TAG)
    } else {
                                        # receive the init information from
                                        # the root
        .PVM.recv (.PVM.gettid (group, rootinst), .SPRNG.INIT.TAG)        
        seed <- .PVM.upkint (1)
        kind <- .PVM.upkint (1)
        para <- .PVM.upkint (1)
    }
    .Call ("r_init_sprng", as.integer (kind),
           as.integer (.PVM.getinst ()),
           as.integer (.PVM.gsize (group)),
           as.integer (seed), as.integer (para))
                                        # enable user-defined RNG
    RNGkind ("user")
}

pack.sprng <- function () {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    .Call ("r_pack_sprng")
}

unpack.sprng <- function (rngstate) {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    if (!is.character (rngstate) || length (rngstate) > 1) {
        stop("'rngstate' must be a character string of length 1.")
    }
    .Call ("r_unpack_sprng", as.character (rngstate))
}

free.sprng <- function (kind.old = c("Marsaglia-Multicarry",
                                     "Kinderman-Ramage")) {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    ## restore old RNG kind
    RNGkind (kind.old[1], kind.old[2])
    .Call ("r_free_sprng")
}

spawn.sprng <- function (nspawn) {
    if (!@R_HAVE_SPRNG@) {
        stop ("Sorry, SPRNG is not available")
    }
    .Call ("r_spawn_sprng", as.integer (nspawn))
}
